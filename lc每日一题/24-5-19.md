# [1535. 找出数组游戏的赢家](https://leetcode.cn/problems/find-the-winner-of-an-array-game/)

给你一个由 **不同** 整数组成的整数数组 `arr` 和一个整数 `k` 。

每回合游戏都在数组的前两个元素（即 `arr[0]` 和 `arr[1]` ）之间进行。比较 `arr[0]` 与 `arr[1]` 的大小，较大的整数将会取得这一回合的胜利并保留在位置 `0` ，较小的整数移至数组的末尾。当一个整数赢得 `k` 个连续回合时，游戏结束，该整数就是比赛的 **赢家** 。

返回赢得比赛的整数。

题目数据 **保证** 游戏存在赢家。

 

**示例 1：**

```
输入：arr = [2,1,3,5,4,6,7], k = 2
输出：5
解释：一起看一下本场游戏每回合的情况：

因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。
```

**示例 2：**

```
输入：arr = [3,2,1], k = 10
输出：3
解释：3 将会在前 10 个回合中连续获胜。
```

**示例 3：**

```
输入：arr = [1,9,8,2,3,7,6,4,5], k = 7
输出：9
```

**示例 4：**

```
输入：arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000
输出：99
```

 

**提示：**

- `2 <= arr.length <= 10^5`
- `1 <= arr[i] <= 10^6`
- `arr` 所含的整数 **各不相同** 。
- `1 <= k <= 10^9`

## 思路：模拟即可

考虑游戏执行的流程，本质上是在从左到右遍历 $arr$ ，求数组最大值（打擂台）。我们要找**首个**连续 $k$ 回合都是最大值的数

示例一中的 $arr=[2,1,3,5,4,6,7]，k=2$ ，从左到右遍历的过程中，历史最大值依次为 $2,3,5,6,7$ ，其中元素$5$ 是首个连续 $k$ 回合都是最大值的数。

如果遍历完 $arr$ 也没找到这样的数，那么答案就是 $arr$ 中的最大值 $mx$ ，因为此时比 $mx$ 小的数都会移到 $mx$ 的右边，所以后面比大小都是 $mx$  胜利。

具体算法如下：

1. 初始化 $mx=arr[0]，win=0$ ，从 $arr[1]$ 开始遍历数组。其中 $win$ 来统计 $mx$ 连续多少个回合获胜。
2. 如果 $arr[i]>mx$ ，更新 $mx=arr[i]$ 以及 $win=0$ 。
3. 把 $win+1$ ，如果 $win==k$ 就退出循环。
4. 遍历结束或者中途退出循环，返回 $mx$ 即可。 

## 1. Java

```java
class Solution {
    public int getWinner(int[] arr, int k) {
        int mx = arr[0];
        int win = 0;
        for (int i = 1; i < arr.length && win < k; i++) {
            if (arr[i] > mx) { // 新的最大值
                mx = arr[i];
                win = 0;
            }
            win++; // 获胜回合 +1
        }
        return mx;
    }
}
```

## 2. Python

```python
class Solution:
    def getWinner(self, arr: List[int], k: int) -> int:
        mx = arr[0]
        win = -1
        for x in arr:
            if x > mx:
                mx = x
                win = 0
            win += 1
            if win == k:
                break
        return mx
```

