# [1953. 你可以工作的最大周数](https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work/)

给你 `n` 个项目，编号从 `0` 到 `n - 1` 。同时给你一个整数数组 `milestones` ，其中每个 `milestones[i]` 表示第 `i` 个项目中的阶段任务数量。

你可以按下面两个规则参与项目中的工作：

- 每周，你将会完成 **某一个** 项目中的 **恰好一个** 阶段任务。你每周都 **必须** 工作。
- 在 **连续的** 两周中，你 **不能** 参与并完成同一个项目中的两个阶段任务。

一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 **停止工作** 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。

返回在不违反上面规则的情况下你 **最多** 能工作多少周。

 

**示例 1：**

```
输入：milestones = [1,2,3]
输出：6
解释：一种可能的情形是：
- 第 1 周，你参与并完成项目 0 中的一个阶段任务。
- 第 2 周，你参与并完成项目 2 中的一个阶段任务。
- 第 3 周，你参与并完成项目 1 中的一个阶段任务。
- 第 4 周，你参与并完成项目 2 中的一个阶段任务。
- 第 5 周，你参与并完成项目 1 中的一个阶段任务。
- 第 6 周，你参与并完成项目 2 中的一个阶段任务。
总周数是 6 。
```

**示例 2：**

```
输入：milestones = [5,2,1]
输出：7
解释：一种可能的情形是：
- 第 1 周，你参与并完成项目 0 中的一个阶段任务。
- 第 2 周，你参与并完成项目 1 中的一个阶段任务。
- 第 3 周，你参与并完成项目 0 中的一个阶段任务。
- 第 4 周，你参与并完成项目 1 中的一个阶段任务。
- 第 5 周，你参与并完成项目 0 中的一个阶段任务。
- 第 6 周，你参与并完成项目 2 中的一个阶段任务。
- 第 7 周，你参与并完成项目 0 中的一个阶段任务。
总周数是 7 。
注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。
因此，项目 0 中会有一个阶段任务维持未完成状态。
```

## 思路：贪心+数学

该题目可以翻译为：我们需要构造一个尽量长的，相邻元素互不相同的序列，并且每个元素 $x$ 的出现次数不能超过 $milestones[x]$ 。

我们观察上面两个示例可以发现，影响我们最终构造的就是 $milestones[i]$ 中那个特别大的数字。

设 $m=max(milestones)$ ， $s=sum(milestones)$ ，下面分类讨论两种情况。

#### 1. $m > s - m + 1$ 

- 如果序列长度为奇数，假设 $milestones[2]=m$ ，我们可以在偶数下标 $0,2,4, \cdots ,k-1$ 上放置元素 $2$ ，如果还有一个 $2$ 可以放置，那么必然会和其他的 $2$ 相邻。假设 $k=5$ ，我们可以在偶数下标 $0,2,4$ 上放置 $2$ ，奇数下标 $1,3,5$ 上放置其他元素。由此可以看出，**序列中元素 $2$ 的个数比其他元素的个数之和多 $1$** 。
- 如果序列长度为偶数，我们可以在偶数下标 $0,2,4, \cdots ,k-2$ 上放置元素 $2$ ，奇数下标放置其他元素，如果还有 $2$ 多余，可以在结尾再加一个 $2$ ，转化为了序列长度是奇数的情况。

综上，这种情况构造的序列长度即为 $2\times(s - m)+1$ 。

#### 2. $m \leq s-m+1$

我们举例看 $[5,3,2,1]$ 这个例子，我们可以构造如下的序列，

$$
[0,1,0,1,0,1,0,2,0,2,3]
$$

可以看出构造出来的序列长度就是 $s$ ，我们假设排序完成，那么 $milestones[2]=m$ ，假设其他元素的下标就用 $k$ 表示，那么我们可以进行如下构造，

$$
[0,k,0,k,0,k,\cdots]
$$

如果还有剩余元素多余，因为其他的元素出现次数一定是小于等于 $m$ 的，所以我们可以把剩余元素多余穿插在 $[0,k]$ 之间，并且可以保证不重复。

综上，这种情况构造的序列长度即为 $s$ 。

## 代码

#### 1. Java

```java
class Solution {
    public long numberOfWeeks(int[] milestones) {
        long s = 0;
        int m = 0;
        for (int x : milestones) {
            s += x;
            m = Math.max(m, x);
        }
        return m > s - m + 1 ? (s - m) * 2 + 1 : s;
    }
}
```

#### 2. Python

```python
class Solution:
    def numberOfWeeks(self, milestones: List[int]) -> int:
        s = sum(milestones)
        m = max(milestones)
        return (s - m) * 2 + 1 if m > s - m + 1 else s
```
